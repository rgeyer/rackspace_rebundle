#!/usr/bin/env ruby
#
# Launch a Rackspace server via API using image_id
#
# Syntax: launch <server_name> <image_id>
#
# NOTE: you must set RACKSPACE_ACCOUNT and RACKSPACE_API_TOKEN in your environment.
#
# cary@rightscale.com
#
require "rubygems"
require "right_rackspace"
require "pp"
require "yaml"

name = ARGV[0]
image_id = ARGV[1]
output = ARGV[2]
wait_timeout = ARGV[3]
flavor_id = ARGV[4]

timeout_backoff = [2,5,10,15]

unless name && image_id
  puts "Syntax: launch <server_name> <image_id>" 
  exit 1
end

# flavor_id.  This is what rackspace calls their instace sizes.
# NOTE: if you choose a larger flavor, then new VMs 
# must use same size or larger. Smaller sizes will fail.
# So it is recommended that you leave it alone if possible.
flavor_id = flavor_id || 1  # 256M

# output.  One of [human, json, yaml].  If nothing (or an unknown value),
# is supplied, the default is human
output = output || "human"
unless ["human", "json", "yaml"].include?(output)
  output = "human"
end

# wait_timeout. The timeout (in seconds) that the script will block while
# waiting for the instance to become active.  If set to 0 the script will
# return immediately
wait_timeout = wait_timeout.to_i || 0

logger = Logger::new(STDOUT)
logger.level = Logger::Severity::UNKNOWN unless output == "human"


account = ENV["RACKSPACE_ACCOUNT"]
token = ENV["RACKSPACE_API_TOKEN"]
unless account && token
  puts "ERROR: you must define RACKSPACE_ACCOUNT and RACKSPACE_API_TOKEN in your env." 
  exit 1
end

server = {
  :name => name,
  :image_id => image_id.to_i,  
  :flavor_id => flavor_id.to_i      
}

# monkey patch: right_rackspace currently depends on rails .blank? method.
class Object
  def blank?
    respond_to?(:empty?) ? empty? : !self
  end
end

# Create new server using given image_id
rackspace_api = ::Rightscale::Rackspace::Interface::new(account, token ,{:verbose_errors => true, :logger => logger})
data = rackspace_api.create_server(:name => server[:name], :image_id => server[:image_id], :flavor_id => server[:flavor_id] )

begin
  idx=0
  start = Time.now.to_i
  while true
    delta = Time.now.to_i - start
    raise Timeout::Error.new if delta > wait_timeout
    tmp_hash = rackspace_api.get_server(data["server"]["id"])
    server_active = tmp_hash["server"]["status"] == "ACTIVE"
    unless server_active
      sleep timeout_backoff[idx] || timeout_backoff.last
      idx += 1
    else
      data = {"server" => data["server"].merge(tmp_hash["server"])}
      break
    end
  end
rescue Timeout::Error
  puts "Waited #{wait_timeout} seconds for server to become active."
end unless wait_timeout == 0

# Display info - like public IP addr and passwd
case output
  when "human"
    pp data
  when "json"
    puts data.to_json
  when "yaml"
    puts data.to_yaml
end